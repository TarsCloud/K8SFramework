// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 2.4.20.
// **********************************************************************

#ifndef __TOPOLOGY_H_
#define __TOPOLOGY_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Tars.h"
#include "tup/TarsJson.h"
using namespace std;
#include "servant/ServantProxy.h"
#include "servant/Servant.h"


namespace tars
{
    struct Vertex : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.Vertex";
        }
        static string MD5()
        {
            return "cc5e0e2b7b5ef9452273b36ff9f9df39";
        }
        Vertex()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            vertex = "";
            callCount = 0;
            callTime = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(vertex, 0);
            _os.write(callCount, 1);
            _os.write(callTime, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(vertex, 0, true);
            _is.read(callCount, 1, true);
            _is.read(callTime, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["vertex"] = tars::JsonOutput::writeJson(vertex);
            p->value["callCount"] = tars::JsonOutput::writeJson(callCount);
            p->value["callTime"] = tars::JsonOutput::writeJson(callTime);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(vertex,pObj->value["vertex"], true);
            tars::JsonInput::readJson(callCount,pObj->value["callCount"], true);
            tars::JsonInput::readJson(callTime,pObj->value["callTime"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(vertex,"vertex");
            _ds.display(callCount,"callCount");
            _ds.display(callTime,"callTime");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(vertex, true);
            _ds.displaySimple(callCount, true);
            _ds.displaySimple(callTime, false);
            return _os;
        }
    public:
        std::string vertex;
        tars::Int64 callCount;
        tars::Int64 callTime;
    };
    inline bool operator==(const Vertex&l, const Vertex&r)
    {
        return l.vertex == r.vertex && l.callCount == r.callCount && l.callTime == r.callTime;
    }
    inline bool operator!=(const Vertex&l, const Vertex&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const Vertex&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,Vertex&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct Edge : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.Edge";
        }
        static string MD5()
        {
            return "cbc64edd90939d933ee5519662431cc7";
        }
        Edge()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            fromVertex = "";
            toVertex = "";
            callCount = 0;
            callTime = 0;
            spanId = "";
            csTime = 0;
            srTime = 0;
            ssTime = 0;
            crTime = 0;
            csData = "";
            srData = "";
            ssData = "";
            crData = "";
            ret = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(fromVertex, 0);
            _os.write(toVertex, 1);
            _os.write(callCount, 2);
            _os.write(callTime, 3);
            _os.write(spanId, 4);
            _os.write(csTime, 5);
            _os.write(srTime, 6);
            _os.write(ssTime, 7);
            _os.write(crTime, 8);
            _os.write(csData, 9);
            _os.write(srData, 10);
            _os.write(ssData, 11);
            _os.write(crData, 12);
            _os.write(ret, 13);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(fromVertex, 0, true);
            _is.read(toVertex, 1, true);
            _is.read(callCount, 2, true);
            _is.read(callTime, 3, true);
            _is.read(spanId, 4, true);
            _is.read(csTime, 5, true);
            _is.read(srTime, 6, true);
            _is.read(ssTime, 7, true);
            _is.read(crTime, 8, true);
            _is.read(csData, 9, true);
            _is.read(srData, 10, true);
            _is.read(ssData, 11, true);
            _is.read(crData, 12, true);
            _is.read(ret, 13, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["fromVertex"] = tars::JsonOutput::writeJson(fromVertex);
            p->value["toVertex"] = tars::JsonOutput::writeJson(toVertex);
            p->value["callCount"] = tars::JsonOutput::writeJson(callCount);
            p->value["callTime"] = tars::JsonOutput::writeJson(callTime);
            p->value["spanId"] = tars::JsonOutput::writeJson(spanId);
            p->value["csTime"] = tars::JsonOutput::writeJson(csTime);
            p->value["srTime"] = tars::JsonOutput::writeJson(srTime);
            p->value["ssTime"] = tars::JsonOutput::writeJson(ssTime);
            p->value["crTime"] = tars::JsonOutput::writeJson(crTime);
            p->value["csData"] = tars::JsonOutput::writeJson(csData);
            p->value["srData"] = tars::JsonOutput::writeJson(srData);
            p->value["ssData"] = tars::JsonOutput::writeJson(ssData);
            p->value["crData"] = tars::JsonOutput::writeJson(crData);
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(fromVertex,pObj->value["fromVertex"], true);
            tars::JsonInput::readJson(toVertex,pObj->value["toVertex"], true);
            tars::JsonInput::readJson(callCount,pObj->value["callCount"], true);
            tars::JsonInput::readJson(callTime,pObj->value["callTime"], true);
            tars::JsonInput::readJson(spanId,pObj->value["spanId"], true);
            tars::JsonInput::readJson(csTime,pObj->value["csTime"], true);
            tars::JsonInput::readJson(srTime,pObj->value["srTime"], true);
            tars::JsonInput::readJson(ssTime,pObj->value["ssTime"], true);
            tars::JsonInput::readJson(crTime,pObj->value["crTime"], true);
            tars::JsonInput::readJson(csData,pObj->value["csData"], true);
            tars::JsonInput::readJson(srData,pObj->value["srData"], true);
            tars::JsonInput::readJson(ssData,pObj->value["ssData"], true);
            tars::JsonInput::readJson(crData,pObj->value["crData"], true);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(fromVertex,"fromVertex");
            _ds.display(toVertex,"toVertex");
            _ds.display(callCount,"callCount");
            _ds.display(callTime,"callTime");
            _ds.display(spanId,"spanId");
            _ds.display(csTime,"csTime");
            _ds.display(srTime,"srTime");
            _ds.display(ssTime,"ssTime");
            _ds.display(crTime,"crTime");
            _ds.display(csData,"csData");
            _ds.display(srData,"srData");
            _ds.display(ssData,"ssData");
            _ds.display(crData,"crData");
            _ds.display(ret,"ret");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(fromVertex, true);
            _ds.displaySimple(toVertex, true);
            _ds.displaySimple(callCount, true);
            _ds.displaySimple(callTime, true);
            _ds.displaySimple(spanId, true);
            _ds.displaySimple(csTime, true);
            _ds.displaySimple(srTime, true);
            _ds.displaySimple(ssTime, true);
            _ds.displaySimple(crTime, true);
            _ds.displaySimple(csData, true);
            _ds.displaySimple(srData, true);
            _ds.displaySimple(ssData, true);
            _ds.displaySimple(crData, true);
            _ds.displaySimple(ret, false);
            return _os;
        }
    public:
        std::string fromVertex;
        std::string toVertex;
        tars::Int64 callCount;
        tars::Int64 callTime;
        std::string spanId;
        tars::Int64 csTime;
        tars::Int64 srTime;
        tars::Int64 ssTime;
        tars::Int64 crTime;
        std::string csData;
        std::string srData;
        std::string ssData;
        std::string crData;
        std::string ret;
    };
    inline bool operator==(const Edge&l, const Edge&r)
    {
        return l.fromVertex == r.fromVertex && l.toVertex == r.toVertex && l.callCount == r.callCount && l.callTime == r.callTime && l.spanId == r.spanId && l.csTime == r.csTime && l.srTime == r.srTime && l.ssTime == r.ssTime && l.crTime == r.crTime && l.csData == r.csData && l.srData == r.srData && l.ssData == r.ssData && l.crData == r.crData && l.ret == r.ret;
    }
    inline bool operator!=(const Edge&l, const Edge&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const Edge&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,Edge&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct Graph : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.Graph";
        }
        static string MD5()
        {
            return "6ca707d7e5ff7c7c1cd5db5a9127b5e9";
        }
        Graph()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(vs, 0);
            _os.write(es, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(vs, 0, true);
            _is.read(es, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["vs"] = tars::JsonOutput::writeJson(vs);
            p->value["es"] = tars::JsonOutput::writeJson(es);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(vs,pObj->value["vs"], true);
            tars::JsonInput::readJson(es,pObj->value["es"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(vs,"vs");
            _ds.display(es,"es");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(vs, true);
            _ds.displaySimple(es, false);
            return _os;
        }
    public:
        vector<tars::Vertex> vs;
        vector<tars::Edge> es;
    };
    inline bool operator==(const Graph&l, const Graph&r)
    {
        return l.vs == r.vs && l.es == r.es;
    }
    inline bool operator!=(const Graph&l, const Graph&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const Graph&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,Graph&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct Summary : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.Summary";
        }
        static string MD5()
        {
            return "cc5e0e2b7b5ef9452273b36ff9f9df39";
        }
        Summary()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            name = "";
            startTime = 0;
            endTime = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(name, 0);
            _os.write(startTime, 1);
            _os.write(endTime, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(name, 0, true);
            _is.read(startTime, 1, true);
            _is.read(endTime, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["name"] = tars::JsonOutput::writeJson(name);
            p->value["startTime"] = tars::JsonOutput::writeJson(startTime);
            p->value["endTime"] = tars::JsonOutput::writeJson(endTime);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(name,pObj->value["name"], true);
            tars::JsonInput::readJson(startTime,pObj->value["startTime"], true);
            tars::JsonInput::readJson(endTime,pObj->value["endTime"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(name,"name");
            _ds.display(startTime,"startTime");
            _ds.display(endTime,"endTime");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(name, true);
            _ds.displaySimple(startTime, true);
            _ds.displaySimple(endTime, false);
            return _os;
        }
    public:
        std::string name;
        tars::Int64 startTime;
        tars::Int64 endTime;
    };
    inline bool operator==(const Summary&l, const Summary&r)
    {
        return l.name == r.name && l.startTime == r.startTime && l.endTime == r.endTime;
    }
    inline bool operator!=(const Summary&l, const Summary&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const Summary&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,Summary&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }


    /* callback of async proxy for client */
    class TopologyPrxCallback: public tars::ServantProxyCallback
    {
    public:
        virtual ~TopologyPrxCallback(){}
        virtual void callback_graphFunction(tars::Int32 ret,  const vector<tars::Graph>& graph)
        { throw std::runtime_error("callback_graphFunction() override incorrect."); }
        virtual void callback_graphFunction_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_graphFunction_exception() override incorrect."); }

        virtual void callback_graphServer(tars::Int32 ret,  const vector<tars::Graph>& graph)
        { throw std::runtime_error("callback_graphServer() override incorrect."); }
        virtual void callback_graphServer_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_graphServer_exception() override incorrect."); }

        virtual void callback_graphTrace(tars::Int32 ret,  const tars::Graph& graph)
        { throw std::runtime_error("callback_graphTrace() override incorrect."); }
        virtual void callback_graphTrace_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_graphTrace_exception() override incorrect."); }

        virtual void callback_listFunction(tars::Int32 ret,  const vector<std::string>& fs)
        { throw std::runtime_error("callback_listFunction() override incorrect."); }
        virtual void callback_listFunction_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_listFunction_exception() override incorrect."); }

        virtual void callback_listTrace(tars::Int32 ret,  const vector<std::string>& ts)
        { throw std::runtime_error("callback_listTrace() override incorrect."); }
        virtual void callback_listTrace_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_listTrace_exception() override incorrect."); }

        virtual void callback_listTraceSummary(tars::Int32 ret,  const vector<tars::Summary>& ts)
        { throw std::runtime_error("callback_listTraceSummary() override incorrect."); }
        virtual void callback_listTraceSummary_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_listTraceSummary_exception() override incorrect."); }

    public:
        virtual const map<std::string, std::string> & getResponseContext() const
        {
            CallbackThreadData * pCbtd = CallbackThreadData::getData();
            assert(pCbtd != NULL);

            if(!pCbtd->getContextValid())
            {
                throw TC_Exception("cann't get response context");
            }
            return pCbtd->getResponseContext();
        }

    public:
        virtual int onDispatch(tars::ReqMessagePtr msg)
        {
            static ::std::string __Topology_all[]=
            {
                "graphFunction",
                "graphServer",
                "graphTrace",
                "listFunction",
                "listTrace",
                "listTraceSummary"
            };
            pair<string*, string*> r = equal_range(__Topology_all, __Topology_all+6, string(msg->request.sFuncName));
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __Topology_all)
            {
                case 0:
                {
                    if (msg->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_graphFunction_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    vector<tars::Graph> graph;
                    _is.read(graph, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_graphFunction(_ret, graph);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (msg->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_graphServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    vector<tars::Graph> graph;
                    _is.read(graph, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_graphServer(_ret, graph);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (msg->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_graphTrace_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    tars::Graph graph;
                    _is.read(graph, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_graphTrace(_ret, graph);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (msg->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_listFunction_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    vector<std::string> fs;
                    _is.read(fs, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_listFunction(_ret, fs);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    if (msg->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_listTrace_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    vector<std::string> ts;
                    _is.read(ts, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_listTrace(_ret, ts);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    if (msg->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_listTraceSummary_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    vector<tars::Summary> ts;
                    _is.read(ts, 5, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_listTraceSummary(_ret, ts);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    };
    typedef tars::TC_AutoPtr<TopologyPrxCallback> TopologyPrxCallbackPtr;

    /* callback of coroutine async proxy for client */
    class TopologyCoroPrxCallback: public TopologyPrxCallback
    {
    public:
        virtual ~TopologyCoroPrxCallback(){}
    public:
        virtual const map<std::string, std::string> & getResponseContext() const { return _mRspContext; }

        virtual void setResponseContext(const map<std::string, std::string> &mContext) { _mRspContext = mContext; }

    public:
        int onDispatch(tars::ReqMessagePtr msg)
        {
            static ::std::string __Topology_all[]=
            {
                "graphFunction",
                "graphServer",
                "graphTrace",
                "listFunction",
                "listTrace",
                "listTraceSummary"
            };

            pair<string*, string*> r = equal_range(__Topology_all, __Topology_all+6, string(msg->request.sFuncName));
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __Topology_all)
            {
                case 0:
                {
                    if (msg->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_graphFunction_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        vector<tars::Graph> graph;
                        _is.read(graph, 3, true);
                        setResponseContext(msg->response->context);

                        callback_graphFunction(_ret, graph);

                    }
                    catch(std::exception &ex)
                    {
                        callback_graphFunction_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_graphFunction_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (msg->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_graphServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        vector<tars::Graph> graph;
                        _is.read(graph, 3, true);
                        setResponseContext(msg->response->context);

                        callback_graphServer(_ret, graph);

                    }
                    catch(std::exception &ex)
                    {
                        callback_graphServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_graphServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (msg->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_graphTrace_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        tars::Graph graph;
                        _is.read(graph, 3, true);
                        setResponseContext(msg->response->context);

                        callback_graphTrace(_ret, graph);

                    }
                    catch(std::exception &ex)
                    {
                        callback_graphTrace_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_graphTrace_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (msg->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_listFunction_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        vector<std::string> fs;
                        _is.read(fs, 3, true);
                        setResponseContext(msg->response->context);

                        callback_listFunction(_ret, fs);

                    }
                    catch(std::exception &ex)
                    {
                        callback_listFunction_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_listFunction_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    if (msg->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_listTrace_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        vector<std::string> ts;
                        _is.read(ts, 3, true);
                        setResponseContext(msg->response->context);

                        callback_listTrace(_ret, ts);

                    }
                    catch(std::exception &ex)
                    {
                        callback_listTrace_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_listTrace_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    if (msg->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_listTraceSummary_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        vector<tars::Summary> ts;
                        _is.read(ts, 5, true);
                        setResponseContext(msg->response->context);

                        callback_listTraceSummary(_ret, ts);

                    }
                    catch(std::exception &ex)
                    {
                        callback_listTraceSummary_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_listTraceSummary_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    protected:
        map<std::string, std::string> _mRspContext;
    };
    typedef tars::TC_AutoPtr<TopologyCoroPrxCallback> TopologyCoroPrxCallbackPtr;

    /* proxy for client */
    class TopologyProxy : public tars::ServantProxy
    {
    public:
        typedef map<string, string> TARS_CONTEXT;
        tars::Int32 graphFunction(const std::string & date,const std::string & functionName,vector<tars::Graph> &graph,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(date, 1);
            _os.write(functionName, 2);
            _os.write(graph, 3);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"graphFunction", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(graph, 3, true);
            return _ret;
        }

        void async_graphFunction(TopologyPrxCallbackPtr callback,const std::string &date,const std::string &functionName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(date, 1);
            _os.write(functionName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"graphFunction", _os, context, _mStatus, callback);
        }
        
        void coro_graphFunction(TopologyCoroPrxCallbackPtr callback,const std::string &date,const std::string &functionName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(date, 1);
            _os.write(functionName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"graphFunction", _os, context, _mStatus, callback, true);
        }

        tars::Int32 graphServer(const std::string & date,const std::string & serverName,vector<tars::Graph> &graph,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(date, 1);
            _os.write(serverName, 2);
            _os.write(graph, 3);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"graphServer", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(graph, 3, true);
            return _ret;
        }

        void async_graphServer(TopologyPrxCallbackPtr callback,const std::string &date,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(date, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"graphServer", _os, context, _mStatus, callback);
        }
        
        void coro_graphServer(TopologyCoroPrxCallbackPtr callback,const std::string &date,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(date, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"graphServer", _os, context, _mStatus, callback, true);
        }

        tars::Int32 graphTrace(const std::string & date,const std::string & traceId,tars::Graph &graph,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(date, 1);
            _os.write(traceId, 2);
            _os.write(graph, 3);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"graphTrace", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(graph, 3, true);
            return _ret;
        }

        void async_graphTrace(TopologyPrxCallbackPtr callback,const std::string &date,const std::string &traceId,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(date, 1);
            _os.write(traceId, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"graphTrace", _os, context, _mStatus, callback);
        }
        
        void coro_graphTrace(TopologyCoroPrxCallbackPtr callback,const std::string &date,const std::string &traceId,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(date, 1);
            _os.write(traceId, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"graphTrace", _os, context, _mStatus, callback, true);
        }

        tars::Int32 listFunction(const std::string & date,const std::string & serverName,vector<std::string> &fs,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(date, 1);
            _os.write(serverName, 2);
            _os.write(fs, 3);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"listFunction", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(fs, 3, true);
            return _ret;
        }

        void async_listFunction(TopologyPrxCallbackPtr callback,const std::string &date,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(date, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"listFunction", _os, context, _mStatus, callback);
        }
        
        void coro_listFunction(TopologyCoroPrxCallbackPtr callback,const std::string &date,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(date, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"listFunction", _os, context, _mStatus, callback, true);
        }

        tars::Int32 listTrace(const std::string & date,const std::string & serverName,vector<std::string> &ts,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(date, 1);
            _os.write(serverName, 2);
            _os.write(ts, 3);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"listTrace", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(ts, 3, true);
            return _ret;
        }

        void async_listTrace(TopologyPrxCallbackPtr callback,const std::string &date,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(date, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"listTrace", _os, context, _mStatus, callback);
        }
        
        void coro_listTrace(TopologyCoroPrxCallbackPtr callback,const std::string &date,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(date, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"listTrace", _os, context, _mStatus, callback, true);
        }

        tars::Int32 listTraceSummary(const std::string & date,tars::Int64 beginTime,tars::Int64 endTime,const std::string & serverName,vector<tars::Summary> &ts,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(date, 1);
            _os.write(beginTime, 2);
            _os.write(endTime, 3);
            _os.write(serverName, 4);
            _os.write(ts, 5);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"listTraceSummary", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(ts, 5, true);
            return _ret;
        }

        void async_listTraceSummary(TopologyPrxCallbackPtr callback,const std::string &date,tars::Int64 beginTime,tars::Int64 endTime,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(date, 1);
            _os.write(beginTime, 2);
            _os.write(endTime, 3);
            _os.write(serverName, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"listTraceSummary", _os, context, _mStatus, callback);
        }
        
        void coro_listTraceSummary(TopologyCoroPrxCallbackPtr callback,const std::string &date,tars::Int64 beginTime,tars::Int64 endTime,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(date, 1);
            _os.write(beginTime, 2);
            _os.write(endTime, 3);
            _os.write(serverName, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"listTraceSummary", _os, context, _mStatus, callback, true);
        }

        TopologyProxy* tars_hash(int64_t key)
        {
            return (TopologyProxy*)ServantProxy::tars_hash(key);
        }

        TopologyProxy* tars_consistent_hash(int64_t key)
        {
            return (TopologyProxy*)ServantProxy::tars_consistent_hash(key);
        }

        TopologyProxy* tars_set_timeout(int msecond)
        {
            return (TopologyProxy*)ServantProxy::tars_set_timeout(msecond);
        }

        static const char* tars_prxname() { return "TopologyProxy"; }
    };
    typedef tars::TC_AutoPtr<TopologyProxy> TopologyPrx;

    /* servant for server */
    class Topology : public tars::Servant
    {
    public:
        virtual ~Topology(){}
        virtual tars::Int32 graphFunction(const std::string & date,const std::string & functionName,vector<tars::Graph> &graph,tars::TarsCurrentPtr current) = 0;
        static void async_response_graphFunction(tars::TarsCurrentPtr current, tars::Int32 _ret, const vector<tars::Graph> &graph)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("tars_ret", _ret);
                tarsAttr.put("graph", graph);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["graph"] = tars::JsonOutput::writeJson(graph);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(graph, 3);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 graphServer(const std::string & date,const std::string & serverName,vector<tars::Graph> &graph,tars::TarsCurrentPtr current) = 0;
        static void async_response_graphServer(tars::TarsCurrentPtr current, tars::Int32 _ret, const vector<tars::Graph> &graph)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("tars_ret", _ret);
                tarsAttr.put("graph", graph);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["graph"] = tars::JsonOutput::writeJson(graph);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(graph, 3);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 graphTrace(const std::string & date,const std::string & traceId,tars::Graph &graph,tars::TarsCurrentPtr current) = 0;
        static void async_response_graphTrace(tars::TarsCurrentPtr current, tars::Int32 _ret, const tars::Graph &graph)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("tars_ret", _ret);
                tarsAttr.put("graph", graph);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["graph"] = tars::JsonOutput::writeJson(graph);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(graph, 3);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 listFunction(const std::string & date,const std::string & serverName,vector<std::string> &fs,tars::TarsCurrentPtr current) = 0;
        static void async_response_listFunction(tars::TarsCurrentPtr current, tars::Int32 _ret, const vector<std::string> &fs)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("tars_ret", _ret);
                tarsAttr.put("fs", fs);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["fs"] = tars::JsonOutput::writeJson(fs);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(fs, 3);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 listTrace(const std::string & date,const std::string & serverName,vector<std::string> &ts,tars::TarsCurrentPtr current) = 0;
        static void async_response_listTrace(tars::TarsCurrentPtr current, tars::Int32 _ret, const vector<std::string> &ts)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("tars_ret", _ret);
                tarsAttr.put("ts", ts);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["ts"] = tars::JsonOutput::writeJson(ts);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(ts, 3);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 listTraceSummary(const std::string & date,tars::Int64 beginTime,tars::Int64 endTime,const std::string & serverName,vector<tars::Summary> &ts,tars::TarsCurrentPtr current) = 0;
        static void async_response_listTraceSummary(tars::TarsCurrentPtr current, tars::Int32 _ret, const vector<tars::Summary> &ts)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("tars_ret", _ret);
                tarsAttr.put("ts", ts);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["ts"] = tars::JsonOutput::writeJson(ts);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(ts, 5);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

    public:
        int onDispatch(tars::TarsCurrentPtr _current, vector<char> &_sResponseBuffer)
        {
            static ::std::string __tars__Topology_all[]=
            {
                "graphFunction",
                "graphServer",
                "graphTrace",
                "listFunction",
                "listTrace",
                "listTraceSummary"
            };

            pair<string*, string*> r = equal_range(__tars__Topology_all, __tars__Topology_all+6, _current->getFuncName());
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __tars__Topology_all)
            {
                case 0:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string date;
                    std::string functionName;
                    vector<tars::Graph> graph;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("date", date);
                        tarsAttr.get("functionName", functionName);
                        tarsAttr.getByDefault("graph", graph, graph);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(date, _jsonPtr->value["date"], true);
                        tars::JsonInput::readJson(functionName, _jsonPtr->value["functionName"], true);
                        tars::JsonInput::readJson(graph, _jsonPtr->value["graph"], false);
                    }
                    else
                    {
                        _is.read(date, 1, true);
                        _is.read(functionName, 2, true);
                        _is.read(graph, 3, false);
                    }
                    tars::Int32 _ret = graphFunction(date,functionName,graph, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("tars_ret", _ret);
                            tarsAttr.put("graph", graph);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["graph"] = tars::JsonOutput::writeJson(graph);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(graph, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string date;
                    std::string serverName;
                    vector<tars::Graph> graph;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("date", date);
                        tarsAttr.get("serverName", serverName);
                        tarsAttr.getByDefault("graph", graph, graph);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(date, _jsonPtr->value["date"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(graph, _jsonPtr->value["graph"], false);
                    }
                    else
                    {
                        _is.read(date, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(graph, 3, false);
                    }
                    tars::Int32 _ret = graphServer(date,serverName,graph, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("tars_ret", _ret);
                            tarsAttr.put("graph", graph);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["graph"] = tars::JsonOutput::writeJson(graph);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(graph, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string date;
                    std::string traceId;
                    tars::Graph graph;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("date", date);
                        tarsAttr.get("traceId", traceId);
                        tarsAttr.getByDefault("graph", graph, graph);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(date, _jsonPtr->value["date"], true);
                        tars::JsonInput::readJson(traceId, _jsonPtr->value["traceId"], true);
                        tars::JsonInput::readJson(graph, _jsonPtr->value["graph"], false);
                    }
                    else
                    {
                        _is.read(date, 1, true);
                        _is.read(traceId, 2, true);
                        _is.read(graph, 3, false);
                    }
                    tars::Int32 _ret = graphTrace(date,traceId,graph, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("tars_ret", _ret);
                            tarsAttr.put("graph", graph);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["graph"] = tars::JsonOutput::writeJson(graph);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(graph, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string date;
                    std::string serverName;
                    vector<std::string> fs;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("date", date);
                        tarsAttr.get("serverName", serverName);
                        tarsAttr.getByDefault("fs", fs, fs);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(date, _jsonPtr->value["date"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(fs, _jsonPtr->value["fs"], false);
                    }
                    else
                    {
                        _is.read(date, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(fs, 3, false);
                    }
                    tars::Int32 _ret = listFunction(date,serverName,fs, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("tars_ret", _ret);
                            tarsAttr.put("fs", fs);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["fs"] = tars::JsonOutput::writeJson(fs);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(fs, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string date;
                    std::string serverName;
                    vector<std::string> ts;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("date", date);
                        tarsAttr.get("serverName", serverName);
                        tarsAttr.getByDefault("ts", ts, ts);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(date, _jsonPtr->value["date"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(ts, _jsonPtr->value["ts"], false);
                    }
                    else
                    {
                        _is.read(date, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(ts, 3, false);
                    }
                    tars::Int32 _ret = listTrace(date,serverName,ts, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("tars_ret", _ret);
                            tarsAttr.put("ts", ts);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["ts"] = tars::JsonOutput::writeJson(ts);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(ts, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string date;
                    tars::Int64 beginTime;
                    tars::Int64 endTime;
                    std::string serverName;
                    vector<tars::Summary> ts;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("date", date);
                        tarsAttr.get("beginTime", beginTime);
                        tarsAttr.get("endTime", endTime);
                        tarsAttr.get("serverName", serverName);
                        tarsAttr.getByDefault("ts", ts, ts);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(date, _jsonPtr->value["date"], true);
                        tars::JsonInput::readJson(beginTime, _jsonPtr->value["beginTime"], true);
                        tars::JsonInput::readJson(endTime, _jsonPtr->value["endTime"], true);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        tars::JsonInput::readJson(ts, _jsonPtr->value["ts"], false);
                    }
                    else
                    {
                        _is.read(date, 1, true);
                        _is.read(beginTime, 2, true);
                        _is.read(endTime, 3, true);
                        _is.read(serverName, 4, true);
                        _is.read(ts, 5, false);
                    }
                    tars::Int32 _ret = listTraceSummary(date,beginTime,endTime,serverName,ts, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("tars_ret", _ret);
                            tarsAttr.put("ts", ts);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["ts"] = tars::JsonOutput::writeJson(ts);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(ts, 5);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }
    };


}



#endif
