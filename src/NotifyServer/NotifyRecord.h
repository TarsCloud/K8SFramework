// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 2.4.20.
// **********************************************************************

#ifndef __NOTIFYRECORD_H_
#define __NOTIFYRECORD_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Tars.h"
#include "tup/TarsJson.h"
using namespace std;


namespace tars
{
    struct NotifyRecord : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.NotifyRecord";
        }
        static string MD5()
        {
            return "f3654d19be1c369df958f331e8563fa4";
        }
        NotifyRecord()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            notifyTime = 0;
            app = "";
            server = "";
            podName = "";
            impThread = "";
            level = "";
            message = "";
            source = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (notifyTime != 0)
            {
                _os.write(notifyTime, 1);
            }
            if (app != "")
            {
                _os.write(app, 2);
            }
            if (server != "")
            {
                _os.write(server, 3);
            }
            if (podName != "")
            {
                _os.write(podName, 4);
            }
            if (impThread != "")
            {
                _os.write(impThread, 5);
            }
            if (level != "")
            {
                _os.write(level, 6);
            }
            if (message != "")
            {
                _os.write(message, 7);
            }
            if (source != "")
            {
                _os.write(source, 8);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(notifyTime, 1, false);
            _is.read(app, 2, false);
            _is.read(server, 3, false);
            _is.read(podName, 4, false);
            _is.read(impThread, 5, false);
            _is.read(level, 6, false);
            _is.read(message, 7, false);
            _is.read(source, 8, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["notifyTime"] = tars::JsonOutput::writeJson(notifyTime);
            p->value["app"] = tars::JsonOutput::writeJson(app);
            p->value["server"] = tars::JsonOutput::writeJson(server);
            p->value["podName"] = tars::JsonOutput::writeJson(podName);
            p->value["impThread"] = tars::JsonOutput::writeJson(impThread);
            p->value["level"] = tars::JsonOutput::writeJson(level);
            p->value["message"] = tars::JsonOutput::writeJson(message);
            p->value["source"] = tars::JsonOutput::writeJson(source);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(notifyTime,pObj->value["notifyTime"], false);
            tars::JsonInput::readJson(app,pObj->value["app"], false);
            tars::JsonInput::readJson(server,pObj->value["server"], false);
            tars::JsonInput::readJson(podName,pObj->value["podName"], false);
            tars::JsonInput::readJson(impThread,pObj->value["impThread"], false);
            tars::JsonInput::readJson(level,pObj->value["level"], false);
            tars::JsonInput::readJson(message,pObj->value["message"], false);
            tars::JsonInput::readJson(source,pObj->value["source"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(notifyTime,"notifyTime");
            _ds.display(app,"app");
            _ds.display(server,"server");
            _ds.display(podName,"podName");
            _ds.display(impThread,"impThread");
            _ds.display(level,"level");
            _ds.display(message,"message");
            _ds.display(source,"source");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(notifyTime, true);
            _ds.displaySimple(app, true);
            _ds.displaySimple(server, true);
            _ds.displaySimple(podName, true);
            _ds.displaySimple(impThread, true);
            _ds.displaySimple(level, true);
            _ds.displaySimple(message, true);
            _ds.displaySimple(source, false);
            return _os;
        }
    public:
        tars::Int64 notifyTime;
        std::string app;
        std::string server;
        std::string podName;
        std::string impThread;
        std::string level;
        std::string message;
        std::string source;
    };
    inline bool operator==(const NotifyRecord&l, const NotifyRecord&r)
    {
        return l.notifyTime == r.notifyTime && l.app == r.app && l.server == r.server && l.podName == r.podName && l.impThread == r.impThread && l.level == r.level && l.message == r.message && l.source == r.source;
    }
    inline bool operator!=(const NotifyRecord&l, const NotifyRecord&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const NotifyRecord&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,NotifyRecord&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }


}



#endif
